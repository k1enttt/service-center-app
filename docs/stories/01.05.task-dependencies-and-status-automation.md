# Story 1.5: Task Dependencies and Status Automation

**Epic:** EPIC-01 - Service Center Phase 2 - Workflow, Warranty & Warehouse
**Story ID:** SC-PHASE2-01.05
**Created:** 2025-10-23
**Status:** Draft
**Depends On:** Story 1.4 (Task Execution UI)

---

## Story

**As a** manager,
**I want** tasks to follow a sequential order with automatic ticket status updates,
**so that** technicians cannot skip critical steps and ticket status reflects actual progress.

---

## Acceptance Criteria

1. Add `enforce_sequence` boolean column to task_templates table (default: true)
2. Create database trigger `check_task_sequence_gate()` for strict mode validation
3. Trigger prevents completing task N+1 if task N is not completed (strict mode only)
4. Create database trigger `auto_advance_ticket_status()` to update ticket status
5. When all tasks completed → ticket status = 'completed' automatically
6. When first task starts → ticket status = 'in_progress' automatically (if still pending)
7. Flexible mode (enforce_sequence = false) allows non-sequential completion with UI warning
8. Update tRPC `workflow.completeTask` to return validation errors for sequence violations
9. UI shows visual indicators: locked tasks (strict mode), warning badges (flexible mode)
10. Task completion modal displays warning message in flexible mode

---

## Integration Verification

- **IV1**: Existing manual ticket status changes continue to work independently
- **IV2**: Tickets without tasks can still be completed manually
- **IV3**: Changing ticket status manually does not affect task progression
- **IV4**: Task completion in flexible mode does not block other features

---

## Tasks / Subtasks

### Database Tasks

- [ ] Extend task_templates table (AC: 1)
  - [ ] Add `enforce_sequence` boolean column (default: true)
  - [ ] Create migration to add column
  - [ ] Update existing templates with default value

- [ ] Create task sequence validation trigger (AC: 2, 3)
  - [ ] Create `check_task_sequence_gate()` PostgreSQL function
  - [ ] Trigger fires BEFORE UPDATE on service_ticket_tasks when status changes to 'completed'
  - [ ] Check if template has enforce_sequence = true
  - [ ] If strict mode, verify all previous tasks (sequence_order < current) are completed
  - [ ] Raise exception if validation fails with descriptive error message
  - [ ] Skip validation if flexible mode

- [ ] Create ticket status automation trigger (AC: 4, 5, 6)
  - [ ] Create `auto_advance_ticket_status()` PostgreSQL function
  - [ ] Trigger fires AFTER UPDATE on service_ticket_tasks
  - [ ] When first task starts (pending → in_progress): set ticket to 'in_progress'
  - [ ] When all tasks completed: set ticket to 'completed'
  - [ ] Only auto-advance if ticket is in valid state (not already completed/cancelled)
  - [ ] Log status change to service_ticket_comments for audit trail

### Backend Tasks

- [ ] Update tRPC workflow procedures (AC: 8)
  - [ ] Modify `workflow.completeTask` to handle sequence validation errors
  - [ ] Return structured error with sequence validation details
  - [ ] Include list of incomplete prerequisite tasks in error response
  - [ ] Add `workflow.getTaskDependencies` procedure to fetch prerequisite tasks

- [ ] Add task template configuration (AC: 1)
  - [ ] Extend `template.create` procedure to accept enforce_sequence parameter
  - [ ] Extend `template.update` procedure to allow changing enforce_sequence
  - [ ] Add validation to ensure enforce_sequence is boolean

### Frontend Tasks

- [ ] Update template editor modal (AC: 1)
  - [ ] Add "Enforce Sequential Execution" toggle in template editor
  - [ ] Show help text explaining strict vs flexible mode
  - [ ] Default to true (strict mode)

- [ ] Create task dependency indicators (AC: 9)
  - [ ] Create `TaskDependencyIndicator` component in `src/components/shared/`
  - [ ] Show lock icon for locked tasks in strict mode
  - [ ] Show warning badge for out-of-sequence tasks in flexible mode
  - [ ] Disable "Mark Complete" button for locked tasks
  - [ ] Show tooltip explaining why task is locked

- [ ] Update task completion modal (AC: 10)
  - [ ] Check if completing task out of sequence in flexible mode
  - [ ] Display warning message: "This task is being completed out of sequence"
  - [ ] List incomplete prerequisite tasks
  - [ ] Require confirmation checkbox to proceed

- [ ] Update task execution card (AC: 9)
  - [ ] Integrate TaskDependencyIndicator component
  - [ ] Show visual state: locked (gray), warning (yellow), available (normal)
  - [ ] Update button states based on dependencies

- [ ] Handle error feedback (AC: 8)
  - [ ] Catch sequence validation errors from tRPC
  - [ ] Display toast notification with prerequisite tasks
  - [ ] Prevent modal from closing on validation error

### Integration & Testing Tasks

- [ ] Test manual ticket status changes (IV1)
  - [ ] Manually change ticket status while tasks are in progress
  - [ ] Verify manual changes are not overridden by triggers
  - [ ] Verify manual status changes work independently

- [ ] Test tickets without tasks (IV2)
  - [ ] Create ticket without template
  - [ ] Manually complete ticket
  - [ ] Verify no errors from missing tasks

- [ ] Test task progression independence (IV3)
  - [ ] Start tasks on a ticket
  - [ ] Manually change ticket status
  - [ ] Verify tasks can still progress normally

- [ ] Test flexible mode (IV4)
  - [ ] Create template with enforce_sequence = false
  - [ ] Complete tasks out of order
  - [ ] Verify warning appears but completion succeeds
  - [ ] Verify no blocking errors

---

## Dev Notes

### Database Schema Change

```sql
-- Add enforce_sequence column to task_templates
ALTER TABLE task_templates
ADD COLUMN enforce_sequence BOOLEAN NOT NULL DEFAULT true;

-- Add comment
COMMENT ON COLUMN task_templates.enforce_sequence IS
  'If true, tasks must be completed in sequence_order. If false, tasks can be completed in any order with UI warning.';
```

### Task Sequence Validation Trigger

```sql
CREATE OR REPLACE FUNCTION check_task_sequence_gate()
RETURNS TRIGGER AS $$
DECLARE
  v_enforce_sequence BOOLEAN;
  v_incomplete_count INTEGER;
  v_template_id UUID;
BEGIN
  -- Only check when changing status to 'completed'
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN

    -- Get template_id from ticket
    SELECT template_id INTO v_template_id
    FROM service_tickets
    WHERE id = NEW.ticket_id;

    -- If no template, allow completion
    IF v_template_id IS NULL THEN
      RETURN NEW;
    END IF;

    -- Check if template enforces sequence
    SELECT enforce_sequence INTO v_enforce_sequence
    FROM task_templates
    WHERE id = v_template_id;

    -- If flexible mode, allow completion
    IF NOT v_enforce_sequence THEN
      RETURN NEW;
    END IF;

    -- Check if all previous tasks are completed
    SELECT COUNT(*) INTO v_incomplete_count
    FROM service_ticket_tasks
    WHERE ticket_id = NEW.ticket_id
      AND sequence_order < NEW.sequence_order
      AND status != 'completed'
      AND status != 'skipped';

    -- If any previous tasks incomplete, reject
    IF v_incomplete_count > 0 THEN
      RAISE EXCEPTION 'Cannot complete task: % incomplete prerequisite task(s) must be completed first', v_incomplete_count
        USING HINT = 'Complete previous tasks in sequence or switch template to flexible mode';
    END IF;

  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
CREATE TRIGGER trigger_check_task_sequence_gate
  BEFORE UPDATE ON service_ticket_tasks
  FOR EACH ROW
  EXECUTE FUNCTION check_task_sequence_gate();
```

### Ticket Status Automation Trigger

```sql
CREATE OR REPLACE FUNCTION auto_advance_ticket_status()
RETURNS TRIGGER AS $$
DECLARE
  v_ticket_status ticket_status;
  v_total_tasks INTEGER;
  v_completed_tasks INTEGER;
  v_in_progress_tasks INTEGER;
BEGIN
  -- Get current ticket status
  SELECT status INTO v_ticket_status
  FROM service_tickets
  WHERE id = NEW.ticket_id;

  -- Skip if ticket already in terminal state
  IF v_ticket_status IN ('completed', 'cancelled') THEN
    RETURN NEW;
  END IF;

  -- Count tasks
  SELECT
    COUNT(*),
    COUNT(*) FILTER (WHERE status = 'completed'),
    COUNT(*) FILTER (WHERE status = 'in_progress')
  INTO v_total_tasks, v_completed_tasks, v_in_progress_tasks
  FROM service_ticket_tasks
  WHERE ticket_id = NEW.ticket_id;

  -- Auto-advance to in_progress when first task starts
  IF NEW.status = 'in_progress' AND v_ticket_status = 'pending' THEN
    UPDATE service_tickets
    SET status = 'in_progress',
        updated_at = NOW()
    WHERE id = NEW.ticket_id;

    -- Log to comments
    INSERT INTO service_ticket_comments (ticket_id, comment, created_by_id)
    VALUES (
      NEW.ticket_id,
      'Ticket automatically advanced to In Progress (first task started)',
      NEW.assigned_to_id
    );
  END IF;

  -- Auto-complete ticket when all tasks completed
  IF v_completed_tasks = v_total_tasks AND v_total_tasks > 0 THEN
    UPDATE service_tickets
    SET status = 'completed',
        completed_at = NOW(),
        updated_at = NOW()
    WHERE id = NEW.ticket_id;

    -- Log to comments
    INSERT INTO service_ticket_comments (ticket_id, comment, created_by_id)
    VALUES (
      NEW.ticket_id,
      'Ticket automatically completed (all tasks finished)',
      NEW.assigned_to_id
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
CREATE TRIGGER trigger_auto_advance_ticket_status
  AFTER UPDATE ON service_ticket_tasks
  FOR EACH ROW
  EXECUTE FUNCTION auto_advance_ticket_status();
```

### tRPC Procedure Updates

```typescript
// src/server/routers/workflow.ts

interface TaskDependencyError {
  code: 'TASK_SEQUENCE_VIOLATION';
  message: string;
  incompleteTasks: {
    id: string;
    name: string;
    sequence_order: number;
    status: TaskStatus;
  }[];
}

export const workflowRouter = router({
  // ... existing procedures

  completeTask: publicProcedure
    .input(z.object({
      taskId: z.string().uuid(),
      completionNotes: z.string().min(10)
    }))
    .mutation(async ({ ctx, input }) => {
      if (!ctx.user) throw new TRPCError({ code: 'UNAUTHORIZED' });

      try {
        // Update task status
        const { data: task, error } = await ctx.supabaseAdmin
          .from('service_ticket_tasks')
          .update({
            status: 'completed',
            completed_at: new Date().toISOString(),
            completion_notes: input.completionNotes
          })
          .eq('id', input.taskId)
          .eq('assigned_to_id', ctx.user.id) // Verify ownership
          .select()
          .single();

        if (error) {
          // Check if it's a sequence violation error
          if (error.message.includes('Cannot complete task')) {
            // Fetch incomplete prerequisite tasks
            const { data: incompleteTasks } = await ctx.supabaseAdmin
              .from('service_ticket_tasks')
              .select(`
                id,
                sequence_order,
                status,
                task_type:task_types(name)
              `)
              .eq('ticket_id', task.ticket_id)
              .lt('sequence_order', task.sequence_order)
              .not('status', 'in', ['completed', 'skipped']);

            throw new TRPCError({
              code: 'PRECONDITION_FAILED',
              message: error.message,
              cause: {
                code: 'TASK_SEQUENCE_VIOLATION',
                incompleteTasks: incompleteTasks || []
              }
            });
          }

          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: error.message
          });
        }

        return { success: true, task };
      } catch (err) {
        throw err;
      }
    }),

  getTaskDependencies: publicProcedure
    .input(z.object({ taskId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      if (!ctx.user) throw new TRPCError({ code: 'UNAUTHORIZED' });

      // Get current task
      const { data: currentTask } = await ctx.supabaseAdmin
        .from('service_ticket_tasks')
        .select('ticket_id, sequence_order')
        .eq('id', input.taskId)
        .single();

      if (!currentTask) {
        throw new TRPCError({ code: 'NOT_FOUND' });
      }

      // Get prerequisite tasks
      const { data: prerequisites } = await ctx.supabaseAdmin
        .from('service_ticket_tasks')
        .select(`
          id,
          sequence_order,
          status,
          task_type:task_types(name)
        `)
        .eq('ticket_id', currentTask.ticket_id)
        .lt('sequence_order', currentTask.sequence_order)
        .order('sequence_order');

      return { prerequisites: prerequisites || [] };
    })
});
```

### Template Editor Modal Update

```typescript
// src/components/modals/template-editor-modal.tsx

interface TemplateEditorModalProps {
  open: boolean;
  onClose: () => void;
  templateId?: string;
}

export function TemplateEditorModal({ open, onClose, templateId }: TemplateEditorModalProps) {
  const [enforceSequence, setEnforceSequence] = useState(true);

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl">
        {/* ... other form fields */}

        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label htmlFor="enforce-sequence">Enforce Sequential Execution</Label>
            <p className="text-sm text-muted-foreground">
              Require tasks to be completed in order (strict mode)
            </p>
          </div>
          <Switch
            id="enforce-sequence"
            checked={enforceSequence}
            onCheckedChange={setEnforceSequence}
          />
        </div>

        {!enforceSequence && (
          <Alert variant="warning">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>Flexible Mode</AlertTitle>
            <AlertDescription>
              Technicians can complete tasks in any order. The system will display warnings but won't block completion.
            </AlertDescription>
          </Alert>
        )}

        {/* ... rest of modal */}
      </DialogContent>
    </Dialog>
  );
}
```

### Task Dependency Indicator Component

```typescript
// src/components/shared/task-dependency-indicator.tsx

interface TaskDependencyIndicatorProps {
  task: Task;
  isLocked: boolean;
  hasWarning: boolean;
  prerequisiteTasks?: Task[];
}

export function TaskDependencyIndicator({
  task,
  isLocked,
  hasWarning,
  prerequisiteTasks = []
}: TaskDependencyIndicatorProps) {
  if (!isLocked && !hasWarning) return null;

  return (
    <div className="flex items-center gap-2">
      {isLocked && (
        <Tooltip>
          <TooltipTrigger>
            <Lock className="h-4 w-4 text-muted-foreground" />
          </TooltipTrigger>
          <TooltipContent>
            <div className="space-y-1">
              <p className="font-medium">Task Locked</p>
              <p className="text-sm">Complete these tasks first:</p>
              <ul className="text-sm list-disc list-inside">
                {prerequisiteTasks.map(prereq => (
                  <li key={prereq.id}>
                    {prereq.sequence_order}. {prereq.task_type.name}
                  </li>
                ))}
              </ul>
            </div>
          </TooltipContent>
        </Tooltip>
      )}

      {hasWarning && (
        <Tooltip>
          <TooltipTrigger>
            <AlertTriangle className="h-4 w-4 text-yellow-500" />
          </TooltipTrigger>
          <TooltipContent>
            <p>Completing out of sequence (flexible mode)</p>
          </TooltipContent>
        </Tooltip>
      )}
    </div>
  );
}
```

### Updated Task Execution Card

```typescript
// src/components/shared/task-execution-card.tsx

export function TaskExecutionCard({ task }: { task: Task }) {
  const updateStatus = trpc.workflow.updateTaskStatus.useMutation();
  const completeTask = trpc.workflow.completeTask.useMutation();
  const { data: dependencies } = trpc.workflow.getTaskDependencies.useQuery({
    taskId: task.id
  });

  const [showCompletionModal, setShowCompletionModal] = useState(false);

  // Check if task is locked (strict mode with incomplete prerequisites)
  const incompletePrerequis = dependencies?.prerequisites.filter(
    p => p.status !== 'completed' && p.status !== 'skipped'
  ) || [];

  const isLocked = task.template?.enforce_sequence && incompletePrerequis.length > 0;
  const hasWarning = !task.template?.enforce_sequence && incompletePrerequis.length > 0;

  const handleComplete = async (notes: string) => {
    try {
      await completeTask.mutateAsync({
        taskId: task.id,
        completionNotes: notes
      });
      setShowCompletionModal(false);
      toast.success('Task completed successfully');
    } catch (error) {
      if (error.cause?.code === 'TASK_SEQUENCE_VIOLATION') {
        toast.error(error.message);
      } else {
        toast.error('Failed to complete task');
      }
    }
  };

  return (
    <div className="border rounded-lg p-4 space-y-3">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <h3>{task.task_type.name}</h3>
          <TaskDependencyIndicator
            task={task}
            isLocked={isLocked}
            hasWarning={hasWarning}
            prerequisiteTasks={incompletePrerequis}
          />
        </div>
        <TaskStatusBadge status={task.status} />
      </div>

      <div className="flex gap-2">
        {task.status === 'pending' && (
          <Button
            onClick={() => updateStatus.mutate({ taskId: task.id, status: 'in_progress' })}
            disabled={isLocked}
          >
            Start Task
          </Button>
        )}

        {task.status === 'in_progress' && (
          <>
            <Button
              onClick={() => setShowCompletionModal(true)}
              disabled={isLocked}
            >
              Mark Complete
            </Button>
            <Button
              variant="destructive"
              onClick={() => updateStatus.mutate({ taskId: task.id, status: 'blocked' })}
            >
              Block
            </Button>
          </>
        )}
      </div>

      <TaskCompletionModal
        open={showCompletionModal}
        onClose={() => setShowCompletionModal(false)}
        onSubmit={handleComplete}
        hasWarning={hasWarning}
        prerequisiteTasks={incompletePrerequis}
      />
    </div>
  );
}
```

### Task Completion Modal with Warning

```typescript
// src/components/modals/task-completion-modal.tsx

interface TaskCompletionModalProps {
  open: boolean;
  onClose: () => void;
  onSubmit: (notes: string) => Promise<void>;
  hasWarning?: boolean;
  prerequisiteTasks?: Task[];
}

export function TaskCompletionModal({
  open,
  onClose,
  onSubmit,
  hasWarning = false,
  prerequisiteTasks = []
}: TaskCompletionModalProps) {
  const [notes, setNotes] = useState('');
  const [confirmOutOfOrder, setConfirmOutOfOrder] = useState(false);

  const handleSubmit = async () => {
    if (hasWarning && !confirmOutOfOrder) {
      toast.error('Please confirm out-of-sequence completion');
      return;
    }

    await onSubmit(notes);
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Complete Task</DialogTitle>
        </DialogHeader>

        {hasWarning && (
          <Alert variant="warning">
            <AlertTriangle className="h-4 w-4" />
            <AlertTitle>Out of Sequence</AlertTitle>
            <AlertDescription>
              <p className="mb-2">This task is being completed before:</p>
              <ul className="list-disc list-inside text-sm">
                {prerequisiteTasks.map(task => (
                  <li key={task.id}>
                    {task.sequence_order}. {task.task_type.name} ({task.status})
                  </li>
                ))}
              </ul>
            </AlertDescription>
          </Alert>
        )}

        <div className="space-y-4">
          <div>
            <Label htmlFor="completion-notes">Completion Notes</Label>
            <Textarea
              id="completion-notes"
              placeholder="Describe what was done..."
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              rows={5}
              required
            />
            {notes.length < 10 && notes.length > 0 && (
              <p className="text-sm text-destructive mt-1">
                Minimum 10 characters required
              </p>
            )}
          </div>

          {hasWarning && (
            <div className="flex items-center space-x-2">
              <Checkbox
                id="confirm-out-of-order"
                checked={confirmOutOfOrder}
                onCheckedChange={(checked) => setConfirmOutOfOrder(checked as boolean)}
              />
              <Label htmlFor="confirm-out-of-order" className="text-sm">
                I confirm this task should be completed out of sequence
              </Label>
            </div>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button
            onClick={handleSubmit}
            disabled={notes.length < 10 || (hasWarning && !confirmOutOfOrder)}
          >
            Complete Task
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

### Testing Scenarios

**Scenario 1: Strict Mode - Sequential Enforcement**
- Template: "iPhone Repair" with enforce_sequence = true
- Tasks: 1. Inspection, 2. Diagnosis, 3. Repair, 4. QA
- Expected: Cannot complete task 3 before task 2
- Expected: Lock icon on task 3 while task 2 incomplete

**Scenario 2: Flexible Mode - Warning Only**
- Template: "Generic Repair" with enforce_sequence = false
- Tasks: 1. Inspection, 2. Diagnosis, 3. Repair
- Action: Complete task 3 before task 2
- Expected: Warning message displayed
- Expected: Completion succeeds after confirmation

**Scenario 3: Auto-Advance to In Progress**
- Ticket status: pending
- Action: Start first task
- Expected: Ticket status automatically changes to 'in_progress'
- Expected: Comment logged to ticket

**Scenario 4: Auto-Complete Ticket**
- Ticket with 5 tasks, 4 already completed
- Action: Complete 5th task
- Expected: Ticket status automatically changes to 'completed'
- Expected: completed_at timestamp set
- Expected: Comment logged to ticket

**Scenario 5: Manual Override Still Works**
- Ticket with tasks in progress
- Action: Manually change ticket status to 'completed'
- Expected: Manual change succeeds
- Expected: Tasks remain in their current state

### Testing

**Testing Standards:**
- Follow `docs/architecture/09-testing-strategy.md` when tests are implemented
- Manual testing required for this story

**This Story Testing:**
- **Manual trigger testing** with strict and flexible templates
- **Manual verification** of sequence validation
- **Manual verification** of auto-advance behavior
- **Manual verification** of IV1-IV4

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation | John (PM) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

---

## QA Results

*This section will be populated by the QA agent after implementation review*
