/**
 * Public Service Request API Route
 *
 * Allows unauthenticated users to submit service requests
 * Protected by rate limiting
 */

import { type NextRequest, NextResponse } from 'next/server';
import { rateLimitPublicEndpoint } from '@/middleware/rateLimit';
import { createClient } from '@/utils/supabase/server';
import { z } from 'zod';

// Request validation schema
const serviceRequestSchema = z.object({
  customer_name: z.string().min(2, 'Tên phải có ít nhất 2 ký tự'),
  customer_phone: z
    .string()
    .regex(/^0[0-9]{9}$/, 'Số điện thoại phải bắt đầu bằng 0 và có 10 chữ số'),
  customer_email: z.string().email('Email không hợp lệ').optional(),
  device_type: z.string().min(2, 'Loại thiết bị là bắt buộc'),
  issue_description: z
    .string()
    .min(10, 'Mô tả vấn đề phải có ít nhất 10 ký tự'),
});

export async function POST(request: NextRequest) {
  try {
    // ⚠️ RATE LIMITING - Check before processing
    const rateLimitResponse = rateLimitPublicEndpoint(request);
    if (rateLimitResponse.status === 429) {
      return rateLimitResponse;
    }

    // Parse and validate request body
    const body = await request.json();
    const validatedData = serviceRequestSchema.parse(body);

    // Create Supabase client (server-side, no auth required for public endpoint)
    const supabase = await createClient();

    // Insert service request
    const { data: serviceRequest, error } = await supabase
      .from('service_requests')
      .insert({
        customer_name: validatedData.customer_name,
        customer_phone: validatedData.customer_phone,
        customer_email: validatedData.customer_email || null,
        device_type: validatedData.device_type,
        issue_description: validatedData.issue_description,
        status: 'pending',
        // tracking_token is auto-generated by database trigger
      })
      .select('id, tracking_token')
      .single();

    if (error) {
      console.error('Error creating service request:', error);
      return NextResponse.json(
        {
          error: 'Database Error',
          message: 'Không thể tạo yêu cầu dịch vụ. Vui lòng thử lại.',
        },
        { status: 500 }
      );
    }

    // Success response with tracking token
    return NextResponse.json(
      {
        success: true,
        message:
          'Yêu cầu dịch vụ của bạn đã được gửi thành công. Vui lòng lưu mã theo dõi để kiểm tra trạng thái.',
        tracking_token: serviceRequest.tracking_token,
        request_id: serviceRequest.id,
      },
      {
        status: 201,
        headers: rateLimitResponse.headers as HeadersInit
      }
    );
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          error: 'Validation Error',
          message: 'Dữ liệu không hợp lệ',
          errors: error.issues,
        },
        { status: 400 }
      );
    }

    console.error('Unexpected error:', error);
    return NextResponse.json(
      {
        error: 'Internal Server Error',
        message: 'Đã xảy ra lỗi. Vui lòng thử lại sau.',
      },
      { status: 500 }
    );
  }
}

// GET method for tracking requests
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const trackingToken = searchParams.get('token');

    if (!trackingToken) {
      return NextResponse.json(
        { error: 'Missing tracking token' },
        { status: 400 }
      );
    }

    const supabase = await createClient();

    const { data: serviceRequest, error } = await supabase
      .from('service_requests')
      .select('id, customer_name, device_type, status, created_at')
      .eq('tracking_token', trackingToken)
      .single();

    if (error || !serviceRequest) {
      return NextResponse.json(
        { error: 'Request not found', message: 'Không tìm thấy yêu cầu' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      request: serviceRequest,
    });
  } catch (error) {
    console.error('Error fetching service request:', error);
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  }
}
